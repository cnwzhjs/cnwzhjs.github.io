<!doctype html>

<html lang="en" class="h-full">

<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-2HTT4P5TRX"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-2HTT4P5TRX');
  </script>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  
    
    <meta name="description" content="Tony Huang&#x27;s personal blogs" />
    
  

  
    
      <title>Rust-based OS booting with UEFI (2) - Have a bite</title>
    
  

  
  <link rel="alternate" type="application/atom+xml" title="RSS" href="https://cnwzhjs.github.io/atom.xml">
  

  
  <script type="text/javascript" src="/js/menu.js"></script>
  

  
  <link href="/css/site.css" rel="stylesheet">
  

  
  
</head>

<body class="h-full">
  <div class="min-h-full">
    
    <nav class="border-b border-gray-200 bg-white">
      <div class="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
        <div class="flex h-16 justify-between">
          <div class="flex">
            <div class="flex flex-shrink-0 items-center">
              <span class="border-transparent text-blue-500 inline-flex items-center border-b-2 px-1 pt-1 text-sm font-medium">Have a bite</span>
            </div>
            <div class="hidden sm:-my-px sm:ml-6 sm:flex sm:space-x-8">
              
                
                  
                    
                      <a href="&#x2F;" class="border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700 inline-flex items-center border-b-2 px-1 pt-1 text-sm font-medium">
                        Home
                      </a>
                    
                  
                    
                      <a href="&#x2F;categories&#x2F;" class="border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700 inline-flex items-center border-b-2 px-1 pt-1 text-sm font-medium">
                        Categories
                      </a>
                    
                  
                    
                      <a href="&#x2F;tags&#x2F;" class="border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700 inline-flex items-center border-b-2 px-1 pt-1 text-sm font-medium">
                        Tags
                      </a>
                    
                  
                    
                      <a href="&#x2F;about&#x2F;" class="border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700 inline-flex items-center border-b-2 px-1 pt-1 text-sm font-medium">
                        About
                      </a>
                    
                  
                
              
                
              
            </div>
          </div>
          <div class="hidden sm:ml-6 sm:flex sm:items-center">
            
              <a href="/zh&#x2F;rust-based-os-booting-with-uefi-2&#x2F;" class="border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700 inline-flex items-center border-b-2 px-1 pt-1 text-sm font-medium">ðŸ‡¨ðŸ‡³ ä¸­æ–‡</a>
            
          </div>
          <div class="-mr-2 flex items-center sm:hidden">
            <!-- Mobile menu button -->
            <button id="menu-btn" type="button" class="relative inline-flex items-center justify-center rounded-md bg-white p-2 text-gray-400 hover:bg-gray-100 hover:text-gray-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2" aria-controls="mobile-menu" aria-expanded="false">
              <span class="absolute -inset-0.5"></span>
              <span class="sr-only">Open main menu</span>
              <!-- Menu open: "hidden", Menu closed: "block" -->
              <svg id="menu-img" class="block h-6 w-6" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
              </svg>
              <!-- Menu open: "block", Menu closed: "hidden" -->
              <svg id="close-img" class="hidden h-6 w-6" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true">
                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </button>
          </div>
        </div>
      </div>
  
      <!-- Mobile menu, show/hide based on menu state. -->
      <div class="sm:hidden hidden" id="mobile-menu">
        <div class="space-y-1 pb-3 pt-2">
          
            
              
                
                  <a href="&#x2F;" class="border-transparent text-gray-600 hover:border-gray-300 hover:bg-gray-50 hover:text-gray-800 block border-l-4 py-2 pl-3 pr-4 text-base font-medium">
                    Home
                  </a>
                
              
                
                  <a href="&#x2F;categories&#x2F;" class="border-transparent text-gray-600 hover:border-gray-300 hover:bg-gray-50 hover:text-gray-800 block border-l-4 py-2 pl-3 pr-4 text-base font-medium">
                    Categories
                  </a>
                
              
                
                  <a href="&#x2F;tags&#x2F;" class="border-transparent text-gray-600 hover:border-gray-300 hover:bg-gray-50 hover:text-gray-800 block border-l-4 py-2 pl-3 pr-4 text-base font-medium">
                    Tags
                  </a>
                
              
                
                  <a href="&#x2F;about&#x2F;" class="border-transparent text-gray-600 hover:border-gray-300 hover:bg-gray-50 hover:text-gray-800 block border-l-4 py-2 pl-3 pr-4 text-base font-medium">
                    About
                  </a>
                
              
            
          
            
          
        </div>
        <div class="border-t border-gray-200 pb-3 pt-4">
          <div class="space-y-1">
            
              <a href="/zh&#x2F;rust-based-os-booting-with-uefi-2&#x2F;" class="border-transparent text-gray-600 hover:border-gray-300 hover:bg-gray-50 hover:text-gray-800 block border-l-4 py-2 pl-3 pr-4 text-base font-medium">ðŸ‡¨ðŸ‡³ ä¸­æ–‡</a>
            
          </div>
        </div>
      </div>
    </nav>
    

    <div class="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
      


<div class="post-toc hidden" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content always-active">
        <nav id="TableOfContents">
            <ul>
                
                <li>
                    <a href="https://cnwzhjs.github.io/rust-based-os-booting-with-uefi-2/#what-is-an-os" class="toc-link">What is an OS?</a>
                    
                </li>
                
                <li>
                    <a href="https://cnwzhjs.github.io/rust-based-os-booting-with-uefi-2/#the-cpuid-instruction" class="toc-link">The cpuid instruction</a>
                    
                </li>
                
                <li>
                    <a href="https://cnwzhjs.github.io/rust-based-os-booting-with-uefi-2/#detecting-memory-layout" class="toc-link">Detecting memory layout</a>
                    
                </li>
                
                <li>
                    <a href="https://cnwzhjs.github.io/rust-based-os-booting-with-uefi-2/#detecting-graphics" class="toc-link">Detecting graphics</a>
                    
                </li>
                
                <li>
                    <a href="https://cnwzhjs.github.io/rust-based-os-booting-with-uefi-2/#what-s-next" class="toc-link">What&#x27;s next</a>
                    
                </li>
                
                <li>
                    <a href="https://cnwzhjs.github.io/rust-based-os-booting-with-uefi-2/#read-more" class="toc-link">Read more</a>
                    
                </li>
                
            </ul>
        </nav>
    </div>
</div>


<article class="prose">
    
<h2>
    <a href="https:&#x2F;&#x2F;cnwzhjs.github.io&#x2F;rust-based-os-booting-with-uefi-2&#x2F;">Rust-based OS booting with UEFI (2)</a>
</h2>
<div class="post__meta">
    <span class="post__time">2023-10-24</span>
    
</div>

    <div class="post-content">
      <blockquote>
<p>All code of this tutorial can be accessed at my <a rel="noopener" target="_blank" href="https://github.com/cnwzhjs/blog-uefi-os">GitHub repo</a></p>
</blockquote>
<h3 id="what-is-an-os">What is an OS?</h3>
<p>In modern days, the word 'OS' may denote many things.</p>
<p>OS can be used to name a kernel, e.g. Linux, Mach (the kernel of macOS), and etc.</p>
<p>OS can also be used to name a kernel and a set of userland programs, e.g. GNU/Linux, macOS, and etc.</p>
<p>In this series of articles, we mainly focus on the kernel part of an OS.</p>
<p>In term of an OS kernel, let's talk about what tasks should be done by an OS kernel.</p>
<p>The major role of an OS kernel is to provide a virtualization abstraction of hardware resources, and to provide a set of APIs for userland programs to use these resources.</p>
<p>In this definition, an OS kernel should:</p>
<ol>
<li>Manages computational (CPU, GPU, application specific accelerators) and storage resources (memory, disks, and etc.), and distribute them to userland programs.</li>
<li>Provides a unified interface to operate periphrals (keyboard, mouse, network, and etc.).</li>
</ol>
<p>Therefore, in this episode, we will try to detect the core hardware resources of the device via UEFI interface:</p>
<ol>
<li>CPU</li>
<li>Memory layout</li>
<li>Graphics</li>
</ol>
<span id="continue-reading"></span><h3 id="the-cpuid-instruction">The <code>cpuid</code> instruction</h3>
<p>For all x86 CPUs, there is a special instruction called <code>cpuid</code>. It is used to query the CPU's features. In rust, we can use the <code>raw-cpuid</code> crate to access this instruction.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">print_cpu_info</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> cpuid = CpuId::new();
</span><span>    </span><span style="color:#b48ead;">let</span><span> vendor_info = cpuid.</span><span style="color:#96b5b4;">get_vendor_info</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Vendor: </span><span style="color:#d08770;">{}</span><span>&quot;, vendor_info.</span><span style="color:#96b5b4;">as_str</span><span>());
</span><span>    </span><span style="color:#b48ead;">let</span><span> brand_info = cpuid.</span><span style="color:#96b5b4;">get_processor_brand_string</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Processor: </span><span style="color:#d08770;">{}</span><span>&quot;, brand_info.</span><span style="color:#96b5b4;">as_str</span><span>());
</span><span>    </span><span style="color:#b48ead;">let</span><span> feature_info = cpuid.</span><span style="color:#96b5b4;">get_feature_info</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>    </span><span style="color:#b48ead;">let</span><span> extended_processor_feature_info = cpuid.</span><span style="color:#96b5b4;">get_extended_processor_and_feature_identifiers</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>    </span><span style="color:#b48ead;">let</span><span> advanced_pm_info = cpuid.</span><span style="color:#96b5b4;">get_advanced_power_mgmt_info</span><span>().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Family: </span><span style="color:#d08770;">{:02X}</span><span style="color:#a3be8c;">h, Model: </span><span style="color:#d08770;">{:02X}</span><span style="color:#a3be8c;">h, Step: </span><span style="color:#d08770;">{:02X}</span><span style="color:#a3be8c;">h</span><span>&quot;, feature_info.</span><span style="color:#96b5b4;">family_id</span><span>(), feature_info.</span><span style="color:#96b5b4;">model_id</span><span>(), feature_info.</span><span style="color:#96b5b4;">stepping_id</span><span>());
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Max logical processor ids: </span><span style="color:#d08770;">{}</span><span>&quot;, feature_info.</span><span style="color:#96b5b4;">max_logical_processor_ids</span><span>());
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Features:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">    vmx: </span><span style="color:#d08770;">{}</span><span>&quot;, feature_info.</span><span style="color:#96b5b4;">has_vmx</span><span>());
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">    hypervisor: </span><span style="color:#d08770;">{}</span><span>&quot;, feature_info.</span><span style="color:#96b5b4;">has_hypervisor</span><span>());
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">    tsc: </span><span style="color:#d08770;">{}</span><span>&quot;, feature_info.</span><span style="color:#96b5b4;">has_tsc</span><span>());
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">    psn: </span><span style="color:#d08770;">{}</span><span>&quot;, feature_info.</span><span style="color:#96b5b4;">has_psn</span><span>());
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">    sysenter &amp; sysexit: </span><span style="color:#d08770;">{}</span><span>&quot;, feature_info.</span><span style="color:#96b5b4;">has_sysenter_sysexit</span><span>());
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">    syscall &amp; sysret: </span><span style="color:#d08770;">{}</span><span>&quot;, extended_processor_feature_info.</span><span style="color:#96b5b4;">has_syscall_sysret</span><span>());
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">    svm: </span><span style="color:#d08770;">{}</span><span>&quot;, extended_processor_feature_info.</span><span style="color:#96b5b4;">has_svm</span><span>());
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">    de: </span><span style="color:#d08770;">{}</span><span>&quot;, extended_processor_feature_info.</span><span style="color:#96b5b4;">has_execute_disable</span><span>());
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">    1g pages: </span><span style="color:#d08770;">{}</span><span>&quot;, extended_processor_feature_info.</span><span style="color:#96b5b4;">has_1gib_pages</span><span>());
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">    rdtscp: </span><span style="color:#d08770;">{}</span><span>&quot;, extended_processor_feature_info.</span><span style="color:#96b5b4;">has_rdtscp</span><span>());
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">    invariant tsc: </span><span style="color:#d08770;">{}</span><span>&quot;, advanced_pm_info.</span><span style="color:#96b5b4;">has_invariant_tsc</span><span>());
</span><span>}
</span></code></pre>
<p>In the above code, we fetched CPU's foundamental information. What's more important is detecting CPU features. We see a lot of abbreviations, let's explain the features required by our OS one by one:</p>
<ol>
<li><code>tsc</code>: Time Stamp Counter, a high resolution timer. (this is used to detect if the CPU supports <code>rdtsc</code> instruction)</li>
<li><code>syscall</code> &amp; <code>sysret</code>: System Call and System Return, a pair of instructions used to switch between userland and kernel. (if you read some old OS tutorials, they may use <code>int</code> instruction to switch between userland and kernel. The two new instructions are more efficient than <code>int</code> instruction, and they are most commonly used by modern OSes)</li>
</ol>
<p>For the rest of the features, we will explain them in later episodes.</p>
<h3 id="detecting-memory-layout">Detecting memory layout</h3>
<p>When we came from BIOS era, the memory layout is very simple. The first 1MB of memory is reserved for BIOS, and the rest of memory is available for OS.</p>
<p>However, UEFI provides much more rich features. As a result, the memory layout is much more complicated.</p>
<p>In UEFI, the memory layout is described by a table called <code>EFI_MEMORY_DESCRIPTOR</code>. We can use the <code>SystemTable&lt;Boot&gt;::get_memory_map()</code> from the <code>uefi</code> crate to access this table:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">print_memory_info</span><span>(</span><span style="color:#bf616a;">system_table</span><span>: &amp;</span><span style="color:#b48ead;">mut </span><span>SystemTable&lt;Boot&gt;) {
</span><span>    </span><span style="color:#65737e;">// fetch the memory layout
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> buf = [</span><span style="color:#d08770;">0</span><span style="color:#b48ead;">u8</span><span>; </span><span style="color:#d08770;">16_384</span><span>];
</span><span>    </span><span style="color:#b48ead;">let</span><span> buf_ptr = buf.</span><span style="color:#96b5b4;">as_ptr</span><span>() as </span><span style="color:#b48ead;">usize</span><span>;
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> memory_map = system_table.</span><span style="color:#96b5b4;">boot_services</span><span>().</span><span style="color:#96b5b4;">memory_map</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> buf).</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>
</span><span>    </span><span style="color:#65737e;">// print the memory layout
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Memory map:</span><span>&quot;);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">{:16} {:16} {:12} </span><span style="color:#d08770;">{:8} {}</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Physical Addr</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Virtual Addr</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Num Pages</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Size</span><span>&quot;, &quot;</span><span style="color:#a3be8c;">Type</span><span>&quot;);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> i = </span><span style="color:#d08770;">0</span><span>;
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> total_pages = </span><span style="color:#d08770;">0</span><span>;
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> usable_pages = </span><span style="color:#d08770;">0</span><span>;
</span><span>
</span><span>    </span><span style="color:#b48ead;">for</span><span> descriptor in memory_map.</span><span style="color:#96b5b4;">entries</span><span>() {
</span><span>        total_pages += descriptor.page_count;
</span><span>        </span><span style="color:#b48ead;">if</span><span> descriptor.ty == MemoryType::</span><span style="color:#d08770;">CONVENTIONAL </span><span>{
</span><span>            usable_pages += descriptor.page_count;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#b48ead;">if</span><span> i != </span><span style="color:#d08770;">0 </span><span>&amp;&amp; (i % </span><span style="color:#d08770;">39</span><span>) == </span><span style="color:#d08770;">0 </span><span>{
</span><span>            println!(&quot;</span><span style="color:#a3be8c;">--- MORE ---</span><span>&quot;);
</span><span>            </span><span style="color:#96b5b4;">wait_for_any_key</span><span>(system_table);
</span><span>        }
</span><span>
</span><span>        print!(
</span><span>            &quot;</span><span style="color:#a3be8c;">{:016X} {:016X} {:12} </span><span>&quot;,
</span><span>            descriptor.phys_start,
</span><span>            descriptor.virt_start,
</span><span>            descriptor.page_count,
</span><span>        );
</span><span>
</span><span>        </span><span style="color:#96b5b4;">print_size_of_pages</span><span>(descriptor.page_count as </span><span style="color:#b48ead;">usize</span><span>);
</span><span>
</span><span>        println!(&quot; </span><span style="color:#d08770;">{:?}</span><span style="color:#a3be8c;"> (</span><span style="color:#d08770;">{:?}</span><span style="color:#a3be8c;">)</span><span>&quot;, descriptor.ty, descriptor.att);
</span><span>
</span><span>        i += </span><span style="color:#d08770;">1</span><span>;
</span><span>    }
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">--- END ---</span><span>&quot;);
</span><span>    print!(&quot;</span><span style="color:#a3be8c;">Total: </span><span>&quot;);
</span><span>    </span><span style="color:#96b5b4;">print_size_of_pages</span><span>(total_pages as </span><span style="color:#b48ead;">usize</span><span>);
</span><span>    print!(&quot;</span><span style="color:#a3be8c;">, Usable: </span><span>&quot;);
</span><span>    </span><span style="color:#96b5b4;">print_size_of_pages</span><span>(usable_pages as </span><span style="color:#b48ead;">usize</span><span>);
</span><span>    println!();
</span><span>    println!();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">buf (stack) is located at {:016X}, section:</span><span>&quot;, buf_ptr);
</span><span>    </span><span style="color:#96b5b4;">print_pointer_section</span><span>(buf_ptr, &amp;memory_map);
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> heap_buf = system_table.</span><span style="color:#96b5b4;">boot_services</span><span>().</span><span style="color:#96b5b4;">allocate_pool</span><span>(MemoryType::</span><span style="color:#d08770;">LOADER_DATA</span><span>, </span><span style="color:#d08770;">1024</span><span>).</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>    </span><span style="color:#b48ead;">let</span><span> heap_buf_ptr = heap_buf as </span><span style="color:#b48ead;">usize</span><span>;
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">heap_buf is located at {:016X}, section:</span><span>&quot;, heap_buf_ptr);
</span><span>    </span><span style="color:#96b5b4;">print_pointer_section</span><span>(heap_buf_ptr, &amp;memory_map);
</span><span>    system_table.</span><span style="color:#96b5b4;">boot_services</span><span>().</span><span style="color:#96b5b4;">free_pool</span><span>(heap_buf).</span><span style="color:#96b5b4;">unwrap</span><span>();    
</span><span>}
</span></code></pre>
<p>If you run this code, you will see UEFI segmented memory space into many sections.
What we really care about is the <code>CONVENTIONAL</code> memory section, which is the memory available for OS.</p>
<h3 id="detecting-graphics">Detecting graphics</h3>
<p>Usually OS tutorials only focus on the under-the-hood part of OS kernels. Most of them runs under text mode. However, I have a very different taste on this.</p>
<p>The story goes back to 1995, the first time I met with a computer. That was a Pentium 133MHz computer running MS-DOS 6.22. I was fascinated by the graphics experience that I can operate via QBASIC. This was the first time, I felt that I can unleash my creativity via a computer.</p>
<p>BIOS provides a very simple interface to access graphics interface via <code>int 10h</code>. Most DOS games use this interface to provide an immersive game play experience.</p>
<p>UEFI provides services via a terminology called protocols. The graphics protocol is called <code>EFI_GRAPHICS_OUTPUT_PROTOCOL</code>. Here's the code to access this protocol:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">print_display_info</span><span>(</span><span style="color:#bf616a;">image_handle</span><span>: Handle, </span><span style="color:#bf616a;">system_table</span><span>: &amp;</span><span style="color:#b48ead;">mut </span><span>SystemTable&lt;Boot&gt;) {
</span><span>    </span><span style="color:#b48ead;">let</span><span> boot_services = system_table.</span><span style="color:#96b5b4;">boot_services</span><span>();
</span><span>    </span><span style="color:#b48ead;">let</span><span> gop_handle = boot_services.get_handle_for_protocol::&lt;GraphicsOutput&gt;().</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> gop = </span><span style="color:#b48ead;">unsafe </span><span>{ system_table
</span><span>        .</span><span style="color:#96b5b4;">boot_services</span><span>()
</span><span>        .open_protocol::&lt;GraphicsOutput&gt;(OpenProtocolParams {
</span><span>            handle: gop_handle,
</span><span>            agent: image_handle,
</span><span>            controller: None
</span><span>        }, OpenProtocolAttributes::GetProtocol
</span><span>    ) }.</span><span style="color:#96b5b4;">unwrap</span><span>();
</span><span>
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Supported Modes:</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">for</span><span> mode in gop.</span><span style="color:#96b5b4;">modes</span><span>() {
</span><span>        println!(
</span><span>            &quot;    </span><span style="color:#d08770;">{:4}</span><span style="color:#a3be8c;"> x </span><span style="color:#d08770;">{:4}</span><span style="color:#a3be8c;"> @ </span><span style="color:#d08770;">{:?}</span><span>&quot;,
</span><span>            mode.</span><span style="color:#96b5b4;">info</span><span>().</span><span style="color:#96b5b4;">resolution</span><span>().</span><span style="color:#d08770;">0</span><span>,
</span><span>            mode.</span><span style="color:#96b5b4;">info</span><span>().</span><span style="color:#96b5b4;">resolution</span><span>().</span><span style="color:#d08770;">1</span><span>,
</span><span>            mode.</span><span style="color:#96b5b4;">info</span><span>().</span><span style="color:#96b5b4;">pixel_format</span><span>()
</span><span>        );
</span><span>    };
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> current_mode = gop.</span><span style="color:#96b5b4;">current_mode_info</span><span>();
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Current Mode:</span><span>&quot;);
</span><span>    println!(
</span><span>        &quot;    </span><span style="color:#d08770;">{:4}</span><span style="color:#a3be8c;"> x </span><span style="color:#d08770;">{:4}</span><span style="color:#a3be8c;"> @ </span><span style="color:#d08770;">{:?}</span><span>&quot;,
</span><span>        current_mode.</span><span style="color:#96b5b4;">resolution</span><span>().</span><span style="color:#d08770;">0</span><span>,
</span><span>        current_mode.</span><span style="color:#96b5b4;">resolution</span><span>().</span><span style="color:#d08770;">1</span><span>,
</span><span>        current_mode.</span><span style="color:#96b5b4;">pixel_format</span><span>()
</span><span>    );
</span><span>}
</span></code></pre>
<p>What should be explained in the above code are two APIs:</p>
<ol>
<li>
<p><code>get_handle_for_protocol</code>: This API is used to get the handle of a protocol. In UEFI, a protocol is identified by a GUID. The GUID of graphics output protocol has been hardcoded in the <code>uefi::proto::console::gop::GraphicsOutput</code>. This handle is required to get the actual service.</p>
</li>
<li>
<p><code>open_protocol</code>: This API is used to get the actual service provided by an UEFI driver.</p>
</li>
</ol>
<p>By sequencely invoking these APIs, we can get foundamental features of the graphics device.</p>
<p>Detailed documents can be found at <a rel="noopener" target="_blank" href="https://docs.rs/uefi/0.25.0/uefi/proto/console/gop/struct.GraphicsOutput.html"><code>uefi</code> document</a>.</p>
<p>We can use these APIs to change the resolution of the screen (<code>set_mode(&amp;mut self, mode: &amp;Mode)</code>), to access the framebuffer (<code>frame_buffer(&amp;mut self)</code>), and to use <code>blt</code> to perform screen cleaning and scrolling.</p>
<h3 id="what-s-next">What's next</h3>
<p>In the next episode, we will try to switch the graphics mode, and print logs to the screen.</p>
<h3 id="read-more">Read more</h3>
<p>Previous Article: <a href="/rust-based-os-botting-with-uefi-1/">Get started</a></p>

    </div>

    
    

    <div class="post-footer">
        
            
                <div class="post-tags">
                    
                        <a href="https://cnwzhjs.github.io/tags/uefi/">#uefi</a>
                    
                        <a href="https://cnwzhjs.github.io/tags/efi/">#efi</a>
                    
                        <a href="https://cnwzhjs.github.io/tags/os/">#os</a>
                    
                        <a href="https://cnwzhjs.github.io/tags/rust/">#rust</a>
                    
                </div>
            
            
                <div class="post-nav">
                    
                    
                        <a class="next" href="https:&#x2F;&#x2F;cnwzhjs.github.io&#x2F;rust-based-os-botting-with-uefi-1&#x2F;">Rust-based OS booting with UEFI (1) â€º</a>
                    
                </div>
            

        

    </div>

    
    
</article>


    </div>
  </div>
</body>

</html>
